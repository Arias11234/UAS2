/*
* This file is part of UAS2.
*
* UAS2 is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* UAS2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.

* You should have received a copy of the GNU General Public License
* along with UASv1; if not, write to the Free Software
* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

/**
 *	@file Status.cpp
 */

/*
Server Updates

On Server Load:
svr_update.php?nStat=2&sID=&sSer=&sKey=&aIP=&bIP=&cIP=&dIP=&sPort=&sVer="Moo"&cVer=&cMax=

On Server Start & every 15 minutes there-after: 
svr_update.php?nStat=4&sID=&sSer=&sKey=&cAvg=

On Server Shutdown Schedule & every 15 minutes there-after:
svr_update.php?nStat=3&sID=&sSer=&sKey=&sTTE=&mText="Moo"&cAvg=

sTTTE can be omitted, if it is not, it should be the number of seconds until the server will shut down.
mText can be omittes, if it is not, it can be free-style text explaining why the server is going down.

On server final go down:
svr_update.php?nStat=1&sID=&sSer=&sKey=&sTTE=&mText="Moo"

sTTTE can be omitted, if it is not, it should be the number of seconds until the server will return.
mText can be omittes, if it is not, it can be free-style text explaining why the server is down.

Variables: 
  nStat = New Status.  1=down, 2=loading, 3=countdown to down, 4=running
  sID = Server IS.  Serial number given when server registered.
  sSer = Server Serial.  A 30-character random alphanumeric serial string to prevent server ID 'jacking.'
  sKey = Session Key.  6-charactes.  Generated by server on load.  used to track a session (and server crashes.) Random Number
  aIP =\
  bIP = \IP address: a.b.c.d
  cIP = /
  dIP =/
  sPort = Login server port.
  sVer = String describing server version.  Up to 30 characters. (could eventually be used for sorting)
  cVer = serial of version supported.
  cMax = Max number of simultaneous users based on speed of hardware server is runnign on.
  cAvg = Average number of connected clients in last 5 minutes
  sTTE = Time To next Event.  Time to downing on stat 3, time to server return (estimated) on stat 1.
  mText = Random text string that will be shown in server details for reasons for a server going down or being down. 50 chars max
*/

#include "UAS.h"
#include "Status.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

/***************
 *	constructors/destructors
 **************/

int			CStatus::m_fPrivate			= 1;
char		CStatus::m_strHost[16]		= { ' ', };
int			CStatus::m_sPort			= 0;
char		CStatus::m_strHTTP[500]		= { ' ', };
DWORD		CStatus::m_sID				= 0x0L;
char		CStatus::m_sSer[31]			= { ' ', };
char		CStatus::m_sKey[7]			= { ' ', };
char		CStatus::m_cVer[31]			= { ' ', };
DWORD		CStatus::m_dwMax = 0x0L;

char		CStatus::m_strOutput[500]	= { ' ', };
char		CStatus::m_strSend[1024]	= { ' ', };
char		CStatus::m_mText[51]		= { ' ', };
DWORD		CStatus::m_sTTE				= 0x0L;
DWORD		CStatus::m_cAvg				= 0x0L;
char		CStatus::m_cVersion[10]		= { ' ', };
byte		CStatus::m_nStat			= 0x00;
SOCKET		CStatus::m_Socket;
WSADATA		CStatus::m_wsaData;
SOCKET		CStatus::m_SendSocket;
byte		CStatus::m_bServer[4]		= { 0,0,0,0 };
int			CStatus::m_ServerPort		= 0;
unsigned long	CStatus::m_ulLastUpdate = 0;

CStatus::CStatus()
{

}

CStatus::~CStatus()
{

}

void CStatus::Clear()
{
	m_fPrivate = true;
	sprintf(m_strHost,"127.0.0.1");
	m_sPort = 80;
	sprintf(m_strHTTP,"                               ");
	m_sID = 0x0L;
	sprintf(m_sSer,"                              ");
	sprintf(m_sKey,"000000");
	sprintf(m_cVer,"0000000000000");
	m_dwMax = 0x0L;
}

void CStatus::ServerLoad()
{
	char strOne[200];

	sprintf(strOne,"GET %ssvr_update.php?nStat=2&sID=%d&sSer=%s&sKey=%s&aIP=%d&bIP=%d&cIP=%d&dIP=%d&sPort=%d&sVer=\"UASv1.2\"&cVer=%s&cMax=%d",m_strHTTP,m_sID,m_sSer,&m_sKey,m_bServer[0],m_bServer[1],m_bServer[2],m_bServer[3],m_ServerPort,m_cVersion,m_dwMax);

	SendHTTP(strOne);
}

void CStatus::ServerStart()
{
	sprintf(m_strOutput,"GET %ssvr_update.php?nStat=4&sID=%d&sSer=%s&sKey=%s&cAvg=%d",m_strHTTP,m_sID,m_sSer,m_sKey,m_cAvg);

	SendHTTP(m_strOutput);
}

void CStatus::UpDate( )
{
	sprintf(m_strOutput,"GET %ssvr_update.php?nStat=4&sID=%d&sSer=%s&sKey=%s&cAvg=%d",m_strHTTP,m_sID,m_sSer,m_sKey,m_cAvg);

	SendHTTP(m_strOutput);
}

void CStatus::ServerShutdown()
{
	sprintf(m_strOutput,"GET %ssvr_update.php?nStat=3&sID=%d&sSer=%s&sKey=%s&sTTE=%d&mText=\"Normal_Shutdown\"&cAvg=0",m_strHTTP,m_sID,m_sSer,m_sKey,m_sTTE);
	SendHTTP(m_strOutput);
}

void CStatus::ServerOffline()
{
	sprintf(m_strOutput,"GET %ssvr_update.php?nStat=1&sID=%d&sSer=%s&sKey=%s&sTTE=%d&mText=\"Offline\"",m_strHTTP,m_sID,m_sSer,m_sKey,m_sTTE);
	SendHTTP(m_strOutput);
}

void CStatus::SendHTTP(char* strOutput)
{
	char strTwo[400]	= { ' ', };
	char strSend[425]	= { ' ', };

	SOCKADDR_IN	saSockAddr;
	saSockAddr.sin_family		= AF_INET;
	saSockAddr.sin_port			= htons( m_sPort );
	saSockAddr.sin_addr.s_addr	= inet_addr( m_strHost );
	int strLen = sizeof( strOutput );

	sprintf(strTwo, "\r\nHTTP/1.1\r\nAccept:image/gif,image/x-xbitmap,image/jpeg,image/pjpeg,application/vnd.ms-powerpoint,application/vnd.ms-excel,application/msword,*/*\r\nAccept-Language:en-us\r\nAccept-Encoding:gzip,deflate\r\nUser-Agent:UAS\r\nHost:%s:%d\r\nConnection:Keep-Alive\r\n", m_strHost,m_sPort);
	sprintf(strSend,"%s %s",strOutput,strTwo);

	m_SendSocket = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );

	m_ulLastUpdate = timeGetTime( ); // Update Time of Last Status Transmission

	
	if( m_fPrivate == 1)
	{
		// Private Server do not send data messages
	}
	else
	{
		connect(m_SendSocket, (SOCKADDR *)&saSockAddr, sizeof( SOCKADDR ) );
		//
		send(m_SendSocket, (char *)strSend, sizeof( strSend ), NULL);
		//
		closesocket(m_SendSocket);
	}
	
}